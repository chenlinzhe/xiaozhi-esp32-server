async def check_teaching_timeout(self, user_id: str) -> Optional[Dict[str, Any]]:
    #     """检查教学会话是否超时 - 优化版本，支持渐进式提示和步骤跳转
        
    #     Args:
    #         user_id: 用户ID
            
    #     Returns:
    #         Dict: 超时处理结果，如果没有超时返回None
    #     """
    #     self.logger.info(f"=== 检查教学超时（优化版） ===")
    #     self.logger.info(f"用户ID: {user_id}")
        
    #     session_data = self.redis_client.get_session_data(f"teaching_{user_id}")
    #     self.logger.info(f"会话数据: {session_data}")
        
    #     if not session_data or not session_data.get("waiting_for_response"):
    #         self.logger.info(f"没有等待响应的会话，无需检查超时")
    #         return None
        
    #     wait_start_time = session_data.get("wait_start_time")
    #     if wait_start_time is None:
    #         self.logger.info(f"等待开始时间未设置，跳过超时检查")
    #         return None
            
    #     current_time = time.time()
    #     wait_duration = current_time - wait_start_time
        
    #     # 获取当前步骤的超时时间
    #     scenario_id = session_data.get("scenario_id")
    #     current_step_index = session_data.get("current_step", 0)
        
    #     # 获取当前步骤配置
    #     steps = await self.dialogue_service._get_scenario_steps(scenario_id)
    #     if steps and current_step_index < len(steps):
    #         current_step = steps[current_step_index]
    #         timeout_seconds = current_step.get("timeoutSeconds", self.WAIT_TIME_MAX)
    #     else:
    #         timeout_seconds = self.WAIT_TIME_MAX
        
    #     self.logger.info(f"等待开始时间: {wait_start_time}")
    #     self.logger.info(f"当前时间: {current_time}")
    #     self.logger.info(f"等待时长: {wait_duration}秒")
    #     self.logger.info(f"超时时间: {timeout_seconds}秒")
        
    #     # 检查渐进式提示
    #     if self.PROGRESSIVE_TIMEOUT_CONFIG.get("enabled", False):
    #         warning_threshold = timeout_seconds * self.PROGRESSIVE_TIMEOUT_CONFIG["warning_timeout"]
    #         final_threshold = timeout_seconds * self.PROGRESSIVE_TIMEOUT_CONFIG["final_timeout"]
            
    #         # 检查是否需要发出警告提示
    #         if (wait_duration >= warning_threshold and 
    #             not session_data.get("warning_sent", False)):
    #             self.logger.info(f"发出警告提示（{wait_duration}秒 >= {warning_threshold}秒）")
    #             session_data["warning_sent"] = True
    #             self.redis_client.set_session_data(f"teaching_{user_id}", session_data)
                
    #             warning_message = self._get_random_message(self.DEFAULT_FEEDBACK_MESSAGES["warning_messages"])
    #             child_name = session_data.get("child_name", "小朋友")
    #             warning_message = warning_message.replace("{childName}", child_name)
    #             warning_message = warning_message.replace("{文杰}", child_name)
                
    #             return {
    #                 "success": True,
    #                 "action": "warning_reminder",
    #                 "ai_message": warning_message,
    #                 "message": "发出警告提示"
    #             }
            
    #         # 检查是否需要发出最终提醒
    #         elif (wait_duration >= final_threshold and 
    #               not session_data.get("final_reminder_sent", False)):
    #             self.logger.info(f"发出最终提醒（{wait_duration}秒 >= {final_threshold}秒）")
    #             session_data["final_reminder_sent"] = True
    #             self.redis_client.set_session_data(f"teaching_{user_id}", session_data)
                
    #             final_message = self._get_random_message(self.DEFAULT_FEEDBACK_MESSAGES["final_reminder_messages"])
    #             child_name = session_data.get("child_name", "小朋友")
    #             final_message = final_message.replace("{childName}", child_name)
    #             final_message = final_message.replace("{文杰}", child_name)
                
    #             return {
    #                 "success": True,
    #                 "action": "final_reminder",
    #                 "ai_message": final_message,
    #                 "message": "发出最终提醒"
    #             }
        
    #     # 检查是否超过等待时间
    #     if wait_duration >= timeout_seconds:
    #         self.logger.info(f"检测到超时，开始处理超时逻辑")
            
    #         # 获取当前步骤的超时处理配置
    #         if steps and current_step_index < len(steps):
    #             current_step = steps[current_step_index]
    #             self.logger.info(f"当前步骤数据: {current_step}")
                
    #             # 使用auto_reply_on_timeout作为超时消息
    #             auto_reply = current_step.get("autoReplyOnTimeout")
                
    #             self.logger.info(f"自动回复消息: {auto_reply}")
    #             self.logger.info(f"超时后直接走成功条件分支配置")
                
    #             # 优化超时消息，增加鼓励性
    #             if auto_reply:
    #                 timeout_message = auto_reply
    #             else:
    #                 timeout_message = "时间到了，让我们继续学习下一个内容。"
                
    #             # 替换儿童姓名占位符
    #             child_name = session_data.get("child_name", "小朋友")
    #             if timeout_message:
    #                 timeout_message = timeout_message.replace("{childName}", child_name)
    #                 timeout_message = timeout_message.replace("{文杰}", child_name)
    #         else:
    #             self.logger.warning(f"无法获取步骤数据，使用默认超时消息")
    #             timeout_message = "时间到了，让我们继续学习下一个内容。"
            
    #         self.logger.info(f"最终超时消息: {timeout_message}")
            
    #         # 更新会话状态 - 超时后进入下一步
    #         session_data["waiting_for_response"] = False
    #         session_data["warning_sent"] = False
    #         session_data["final_reminder_sent"] = False
            
    #         # 检查是否需要进入下一步
    #         if steps and current_step_index < len(steps):
    #             # 获取当前步骤的最大尝试次数（优先步骤配置，备用场景配置）
    #             step_max_attempts = self._get_step_max_attempts(current_step, session_data)
    #             current_step_retry_count = session_data.get("current_step_retry_count", 0)
                
    #             # 判断是否为叶子节点
    #             is_leaf_step = self._is_leaf_step(current_step)
                
    #             self.logger.info(f"超时检查 - 步骤最大重复次数: {step_max_attempts}")
    #             self.logger.info(f"超时检查 - 当前步骤已尝试次数: {current_step_retry_count}")
    #             self.logger.info(f"超时检查 - 是否为叶子节点: {is_leaf_step}")
                
    #             if is_leaf_step:
    #                 # 叶子节点：检查步骤级别的重试次数
    #                 if current_step_retry_count >= step_max_attempts:
    #                     # 叶子节点超过最大尝试次数，结束教学
    #                     self.logger.warning(f"叶子节点超时且超过最大尝试次数，结束教学")
    #                     final_score = self._calculate_final_score(session_data)
    #                     session_data["completed"] = True
    #                     session_data["final_score"] = final_score
    #                     session_data["completion_reason"] = "timeout_leaf_step_max_attempts_exceeded"
                        
    #                     # 保存会话数据
    #                     self.redis_client.set_session_data(f"teaching_{user_id}", session_data)
                        
    #                     # 生成完成消息
    #                     completion_message = self._generate_completion_message(final_score, child_name)
                        
    #                     return {
    #                         "success": True,
    #                         "action": "completed",
    #                         "ai_message": completion_message,
    #                         "final_score": final_score,
    #                         "message": f"教学完成！最终得分：{final_score}分"
    #                     }
    #                 else:
    #                     # 叶子节点未超过最大尝试次数，增加重试次数并重复输出AI消息列表
    #                     session_data["current_step_retry_count"] = current_step_retry_count + 1
    #                     self.logger.info(f"叶子节点超时但未超过最大尝试次数，增加重试次数: {session_data['current_step_retry_count']}/{step_max_attempts}")
                        
    #                     # 获取步骤的消息列表
    #                     step_id = current_step.get("stepId")
    #                     message_list = None
    #                     if step_id:
    #                         message_list = self._get_step_message_list(step_id)
    #                         self.logger.info(f"超时后获取到步骤 {step_id} 的消息列表: {len(message_list) if message_list else 0} 条消息")
                        
    #                     # 设置等待响应状态
    #                     session_data["waiting_for_response"] = True
    #                     session_data["wait_start_time"] = time.time()
    #                     session_data["warning_sent"] = False
    #                     session_data["final_reminder_sent"] = False
                        
    #                     # 保存会话数据
    #                     self.redis_client.set_session_data(f"teaching_{user_id}", session_data)
                        
    #                     # 构建返回结果 - 使用retry_current_step动作
    #                     result = {
    #                         "success": True,
    #                         "action": "retry_current_step",
    #                         "session_id": f"teaching_{user_id}",
    #                         "current_step": current_step,
    #                         "message": "超时后重试当前步骤",
    #                         "timeoutSeconds": current_step.get("timeoutSeconds", self.WAIT_TIME_MAX),
    #                         "retry_count": session_data["current_step_retry_count"],
    #                         "max_attempts": step_max_attempts,
    #                         "is_leaf_step": True
    #                     }
                        
    #                     # 如果有消息列表，添加到返回结果中
    #                     if message_list:
    #                         result["message_list"] = message_list
    #                         result["message_count"] = len(message_list)
    #                         self.logger.info(f"叶子节点超时后返回消息列表，消息数量: {len(message_list)}")
                        
    #                     return result
    #             else:
    #                 # 非叶子节点：使用原有的分支配置逻辑
    #                 if current_step_retry_count >= step_max_attempts:
    #                     # 超过最大尝试次数，使用完全不匹配分支配置进入下一步
    #                     next_step_id = current_step.get("noMatchNextStepId") or current_step.get("noMatchStepId")
    #                     if next_step_id:
    #                         self.logger.info(f"超时且超过最大尝试次数，使用noMatchStepId跳转: {next_step_id}")
    #                         # 查找指定的下一步骤
    #                         next_step_index = self._find_step_by_id(steps, next_step_id)
    #                         if next_step_index is not None:
    #                             session_data["current_step"] = next_step_index
    #                             session_data["current_step_retry_count"] = 0  # 重置新步骤的重试次数
    #                             self.logger.info(f"超时后跳转到指定步骤: {next_step_index}")
    #                         else:
    #                             self.logger.warning(f"超时后未找到指定的下一步骤ID: {next_step_id}，教学结束")
    #                             # 如果找不到指定的步骤，结束教学
    #                             final_score = self._calculate_final_score(session_data)
    #                             session_data["completed"] = True
    #                             session_data["final_score"] = final_score
    #                             session_data["completion_reason"] = "timeout_branch_step_not_found"
                                
    #                             # 保存会话数据
    #                             self.redis_client.set_session_data(f"teaching_{user_id}", session_data)
                                
    #                             # 生成完成消息
    #                             completion_message = self._generate_completion_message(final_score, child_name)
                                
    #                             return {
    #                                 "success": True,
    #                                 "action": "completed",
    #                                 "ai_message": completion_message,
    #                                 "final_score": final_score,
    #                                 "message": f"教学完成！最终得分：{final_score}分"
    #                             }
    #                     else:
    #                         # 没有配置noMatchStepId，结束教学
    #                         self.logger.warning(f"超时且没有配置noMatchStepId，教学结束")
    #                         final_score = self._calculate_final_score(session_data)
    #                         session_data["completed"] = True
    #                         session_data["final_score"] = final_score
    #                         session_data["completion_reason"] = "timeout_no_branch_config"
                            
    #                         # 保存会话数据
    #                         self.redis_client.set_session_data(f"teaching_{user_id}", session_data)
                            
    #                         # 生成完成消息
    #                         completion_message = self._generate_completion_message(final_score, child_name)
                            
    #                         return {
    #                             "success": True,
    #                             "action": "completed",
    #                             "ai_message": completion_message,
    #                             "final_score": final_score,
    #                             "message": f"教学完成！最终得分：{final_score}分"
    #                         }
                    
    #                     # 重置当前步骤重试次数（进入新步骤时重置）
    #                     session_data["current_step_retry_count"] = 0
    #                     self.logger.info(f"超时且超过最大尝试次数，进入下一步: {session_data['current_step']}")
                        
    #                     # 检查是否完成所有步骤
    #                     if session_data["current_step"] >= len(steps):
    #                         self.logger.info(f"已完成所有步骤，教学结束")
    #                         # 教学完成
    #                         final_score = self._calculate_final_score(session_data)
    #                         session_data["completed"] = True
    #                         session_data["final_score"] = final_score
                            
    #                         # 保存会话数据
    #                         self.redis_client.set_session_data(f"teaching_{user_id}", session_data)
                            
    #                         # 生成完成消息
    #                         completion_message = self._generate_completion_message(final_score, child_name)

    #                         # 第624行：切换到自由模式 ✅
    #                         self.set_user_chat_status(user_id, "free_mode")
                            
    #                         return {
    #                             "success": True,
    #                             "action": "completed",
    #                             "ai_message": completion_message,
    #                             "final_score": final_score,
    #                             "message": f"教学完成！最终得分：{final_score}分"
    #                         }
    #                     else:
    #                         # 进入下一步
    #                         next_step = steps[session_data["current_step"]]
                            
    #                         # 保存会话数据
    #                         self.redis_client.set_session_data(f"teaching_{user_id}", session_data)
                            
    #                         return {
    #                             "success": True,
    #                             "action": "next_step",
    #                             "timeoutSeconds": next_step.get("timeoutSeconds", self.WAIT_TIME_MAX),
    #                             "message": "超时后进入下一步"
    #                         }
    #                 else:
    #                     # 非叶子节点未超过最大尝试次数，增加重试次数并继续当前步骤
    #                     session_data["current_step_retry_count"] = current_step_retry_count + 1
    #                     self.logger.info(f"非叶子节点超时但未超过最大尝试次数，增加重试次数: {session_data['current_step_retry_count']}/{step_max_attempts}")
                        
    #                     # 保存会话数据
    #                     self.redis_client.set_session_data(f"teaching_{user_id}", session_data)
                        
    #                     return {
    #                         "success": True,
    #                         "action": "retry_current_step",
    #                         "message": "超时后重试当前步骤",
    #                         "timeoutSeconds": current_step.get("timeoutSeconds", self.WAIT_TIME_MAX),
    #                         "retry_count": session_data["current_step_retry_count"],
    #                         "max_attempts": step_max_attempts,
    #                         "is_leaf_step": False
    #                     }
            
    #         result = {
    #             "success": True,
    #             "action": "timeout_response",
    #             "message": "用户超时，进入下一步"
    #         }
    #         self.logger.info(f"返回超时处理结果: {result}")
    #         return result
    #     else:
    #         self.logger.info(f"未超时，等待时长: {wait_duration}秒 < {timeout_seconds}秒")
        
    #     return None